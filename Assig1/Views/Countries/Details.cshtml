@model Assig1.ViewModels.CountriesViewModel

@{
    ViewData["Title"] = "Details";
}

<div class="text-center mb-5">
    <h1 class="mb-3">@Model.TheCountryDetail.TheCountry.CountryName's Details</h1>
    @if (Model.TheCountryDetail.TheRegion != null)
    {
        <h5>Region: @Model.TheCountryDetail.TheRegion.RegionName</h5>
    }
    else
    {
        <p>Region: Not available</p>
    }
</div>
<div class="row justify-content-center" id="EmissionAlert" align="center" role="alert">
    @*<div class="alert alert-danger" role="alert">
        This is an alert
    </div>*@
</div>
@if (Model.TheCountryDetail.TheRegion != null)
{
    @*<a asp-action="Index" asp-route-countryId="@Model.TheCountryDetail.TheCountry.CountryId" asp-route-regionId="@Model.TheCountryDetail.TheRegion.RegionId" class="btn btn-outline-info">Countries in same Region</a>*@
    <a asp-action="Index" asp-route-countryId="@Model.TheCountryDetail.TheCountry.CountryId" asp-route-id="@Model.TheCountryDetail.TheRegion.RegionId" class="btn btn-outline-info">Countries in same Region</a>

}
else
{
    <a asp-action="Index" asp-route-countryId="" class="btn btn-outline-info">All Countries List</a>
}
@*<a asp-controller="Countries" asp-action="Index" asp-route-id="@Model.Id" class="btn btn-outline-success" >Go Back</a>*@
<a asp-controller="Cities" asp-action="Index" asp-route-countryId="@Model.TheCountryDetail.TheCountry.CountryId" class="btn btn-outline-success">Visit cities</a>

<div id="EmissionData">
    <div class="row mb-3" id="dataDisplay">
        <div class="col-2" id="yearElement">
            <select asp-for="@Model.Year" asp-items="@Model.YearList" class="form-control" id="year">
                <option value="">Select year</option>
            </select>
        </div>

        <div class="col-2" id="chartLegendElement">
            <select asp-for="@Model.ChartLegend" class="form-control" id="chartLegend">
                <option value="Elements">Elements</option>
                <option value="Items">Items</option>
                <option value="Temperature">Temperature</option>
            </select>
        </div>

        <div class="col-2" id="chartAggregationElement">
            <select asp-for="@Model.ChartAggregation" class="form-control" id="chartAggregation">
                <option value="Total">Total</option>
                <option value="Average">Average</option>
            </select>
        </div>

    </div>

    <div>
        <svg width="100%" height="600px" class="border border-primary rounded p-2"></svg>
    </div>

    <!--<div class="row justify-content-end">
        <div class="col-4">-->
            @*<img src="@Model.TheCountryDetail.TheCountry.ImageUrl" class="card-img-top" alt="...">*@


        <!--</div>
    </div>-->
    <div class="accordion" id="accordionExample">
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                    View all items and elements data
                </button>
            </h2>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo" data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <div id="ItemElementInfo">

                        <table class="table table-info">
                            <thead>
                                <tr>
                                    <th>Year</th>
                                    <th>Item</th>
                                    <th>Element</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody class="ItemElementInfo">

                                <tr class="rowData">
                                    <td>Year test</td>
                                    <td>Item test</td>
                                    <td>Element test</td>
                                    <td>Value test</td>
                                </tr>

                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>
@section scripts{
    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        fetch(`/Countries/ItemElementData?countryId=${@Model.CountryId}`)
            .then(response => {
                console.log("response status: " + response.status);
                console.log("response text: " + response.statusText);
                return response.json();
            })
            .then(data => buildTableItem(data))
            .catch(err => console.log(err.message));

        function buildTableItem(dataSet) {
            console.log("This is table item")
            console.log(dataSet)
            console.log(dataSet.length)
            if (dataSet.length > 0) {
                console.log("In if");
                var table = document.querySelector(".ItemElementInfo")
                var previousYear = null;
                var previousItem = null;

                for (let i = 0; i < dataSet.length; i++) {
                    var row = table.querySelector("tr.rowData").cloneNode(true);

                    let tdList = row.querySelectorAll('td');
                    if (dataSet[i].year != previousYear) {
                        tdList[0].innerText = dataSet[i].year;
                        tdList[0].style.borderBottom = "none";
                        tdList[0].style.borderTop = "1px solid";

                    }
                    else {
                        tdList[0].innerText = "";
                        tdList[0].style.borderLeft = "none";
                        tdList[0].style.borderRight = "none";
                        tdList[0].style.borderBottom = "none";
                    }
                    if (dataSet[i].item != previousItem) {
                        tdList[1].innerText = dataSet[i].item;
                        tdList[1].style.borderBottom = "none";
                        tdList[1].style.borderTop = "1px solid";
                        //tdList[2].style.borderBottom = "none";
                        tdList[2].style.borderTop = "1px solid";
                        tdList[3].style.borderTop = "1px solid";
                    }
                    else {
                        tdList[1].innerText = "";
                        tdList[1].style.borderLeft = "none";
                        tdList[1].style.borderRight = "none";
                        tdList[1].style.borderBottom = "none";
                        //tdList[2].style.borderBottom = "none";
                    }
                    tdList[2].innerText = dataSet[i].element;
                    tdList[2].style.borderBottom = "none";
                    tdList[3].innerText = dataSet[i].value;
                    tdList[3].style.borderBottom = "none";

                    previousYear = dataSet[i].year;
                    previousItem = dataSet[i].item;
                    table.appendChild(row);

                    if (i == (dataSet.length - 1)) {
                        table.removeChild(table.querySelector("tr.rowData"))
                    }
                }
            }
            else {
                console.log("In else");
                var alertContainer = document.querySelector("#EmissionAlert");

                var alertElement = document.createElement("div");
                alertElement.className = "alert alert-warning";
                alertElement.setAttribute("role", "alert");

                var message = "There is no emission data in this country.";
                var textNode = document.createTextNode(message);
                alertElement.appendChild(textNode);
                alertContainer.appendChild(alertElement);

                var emissionData = document.getElementById("EmissionData");
                emissionData.classList.add("hideElement");
            }
        }
        // 1 Select SVG element
        const svg = d3.select('svg');

        // 2 Determine the size of the SVG element
        let w = svg.node().getBoundingClientRect().width;
        let h = svg.node().getBoundingClientRect().height;

        console.log("Width: " + w);
        console.log("Height: " + h);

        // 12 Chart margins
        const chartMargins = {
            left: 40,
            right: 25,
            top: 25,
            bottom: 150
        };

        // 12 Update width and height variable to account for the reduction in size caused by margins
        w = w - (chartMargins.left + chartMargins.right);
        h = h - (chartMargins.top + chartMargins.bottom);

        // DDL year event listener
        // Build default legend and aggregation
        let chartLegend = "Elements";
        let chartAggregation = "Total";
        let year = "";
        //let temperatureLegend = "";

        var yearElement = document.getElementById("yearElement");
        var chartAggregationElement = document.getElementById("chartAggregationElement");

        document.querySelector('.row .col-2 #chartLegend').addEventListener('change', legendEvent => {
            chartLegend = legendEvent.target.value;
            console.log("Legend: " + chartLegend);
            updateChartSelection(year, chartLegend, chartAggregation);

        })

        document.querySelector('.row .col-2 #chartAggregation').addEventListener('change', aggregationEvent => {
            chartAggregation = aggregationEvent.target.value;
            console.log("Chart Aggregation: " + chartAggregation);
            updateChartSelection(year, chartLegend, chartAggregation);
        })

        document.querySelector('.row .col-2 #year').addEventListener('change', (yearEvent) => {
            year = yearEvent.target.value;
            console.log("Year: " + year);

            updateChartSelection(year, chartLegend, chartAggregation);

        })

        function updateChartSelection(year, chartLegend, chartAggregation) {
            year = year;
            chartLegend = chartLegend;
            chartAggregation = chartAggregation;

            console.log("UPDATED YEAR: " + year);
            console.log("UPDATED CHART LEGEND: " + chartLegend);
            console.log("UPDATED CHART AGGREGATION: " + chartAggregation);

            if (chartLegend == "Temperature") {
                console.log("In temperature")

                // Hide year element and chart aggregation if user chooses temperature legend
                yearElement.classList.add("hideElement");
                chartAggregationElement.classList.add("hideElement");

                fetch(`/Countries/TemperatureReportData?countryId=${@Model.CountryId}&chartLegend=${chartLegend}`)
                    .then(response => {
                        console.log("response status: " + response.status);
                        console.log("response text: " + response.statusText);
                        return response.json();
                    })
                    .then(data => buildGraphTemperature(data))
                    .catch(err => console.log(err.message));
            }
            else {
                console.log("in other legends")

                // Show element and chart aggregation if user does not choose temperature legend
                yearElement.classList.remove("hideElement");
                chartAggregationElement.classList.remove("hideElement");
                if (year.length > 0) {

                    fetch(`/Countries/CountryEmissionsReportData?countryId=${@Model.CountryId}&year=${year}&chartLegend=${chartLegend}&chartAggregation=${chartAggregation}`)
                        .then(response => {
                            console.log("response status: " + response.status);
                            console.log("response text: " + response.statusText);
                            return response.json();
                        })
                        .then(data => {
                            if (chartLegend == "Items") {
                                buildGraphItem(data)
                            }
                            else {
                                buildGraphElement(data)
                            }
                        })
                        //.then(data => buildTableItem(data))
                        .catch(err => console.log(err.message));
                    }
            }
        }

        // TESTING FOR ELEMENTS TOTAL
        // maybe only need buildgraph element and item, don't need to differentiate element and item because it just builds graph upon data
        // dataSet.length is number of items in the dataSet => elements: 8 for countryid=1
        function buildGraphElement(dataSet) {
            console.log(dataSet)

            // Clear graph
            d3.selectAll('svg > g > *').remove();

            let valueElementsRangeAverage = "";
            let maxValueElementsAverage = "";

            let valueElementsRangeTotal = "";
            let maxValueElementsTotal = "";
            // 4 Calculate the maximum value to be displayed
            // Average
            if (chartAggregation == "Average") {
                valueElementsRangeAverage = d3.extent(dataSet, (d, e) => d.valueElementAverage);
                maxValueElementsAverage = valueElementsRangeAverage[1];

                console.log("Max totalElements average: " + maxValueElementsAverage);
            }
            // Total
            else {
                valueElementsRangeTotal = d3.extent(dataSet, (d, e) => d.valueElementTotal);
                maxValueElementsTotal = valueElementsRangeTotal[1];

                console.log("Max totalElements average: " + maxValueElementsTotal);
            }

            // 4 Calculate the bar dimensions
            const barMargin = 10;
            const barWidth = w / dataSet.length;

            // 8 Create a YScale
            let yScale = "";

            // Average
            if (chartAggregation == "Average") {
                yScale = d3.scaleLinear()
                    .domain([0, maxValueElementsAverage])
                    .range([h, 0]);
            }
            // Total
            else {
                yScale = d3.scaleLinear()
                    .domain([0, maxValueElementsTotal])
                    .range([h, 0]);
            }

            // 10 Create XScale

            // Elements
            let array = Array.from(dataSet, (d, e) => d.element);
            console.log("array: " + array)


            let xScale = d3.scaleBand()
                .domain(array)
                .range([0, w])
                .paddingInner(0.1)

            // example of xScale test:
            console.log("xscale: " + xScale(1))

            // 12.4 Create chartGroup element
            const chartGroup = svg.append('g')
                .classed('chartGroup', true)
                .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

            // 5 Select all 'g' elements and bind the dataSet
            //let barGroups = svg
            //    .selectAll('g')
            //    .data(dataSet);
            // 12.4 Append the barGroups to the chartGroup
            let barGroups = chartGroup
                .selectAll('g')
                .data(dataSet);

            // 6 Add new bar groups
            let newBarGroups = barGroups.enter()
                .append('g')
                .attr('transform', (d, e) => {
                    // 9 Implement yScale
                    //return `translate(${e * barWidth}, ${yScale(d.totalValue)})`;

                    // 10 Implement xScale
                    // Average
                    if (chartAggregation == "Average") {
                        return `translate(${xScale(d.element)}, ${yScale(d.valueElementAverage)})`;
                    }
                    // Total
                    else {
                        return `translate(${xScale(d.element)}, ${yScale(d.valueElementTotal)})`;
                    }

                }); // end transform

            // Add tooltip to show data when hover on bar
            // Reference link: https://perials.github.io/responsive-bar-chart-with-d3/
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "d3-tooltip")
                .style("position", "absolute")
                .style("z-index", "10")
                .style("visibility", "hidden")
                .style("padding", "15px")
                .style("background", "rgba(0,0,0,0.6)")
                .style("border-radius", "5px")
                .style("color", "#fff")
                .text("a simple tooltip");
            // 7 Append new rectangles
            // 11 animate
            newBarGroups
                .append('rect')
                .attr('x', 0) // optional line that can be left out since 0 is the default
                // 9 Implement yScale
                .attr('height', 0)
                .attr('y', (d, e) => {
                    // Average
                    if (chartAggregation == "Average") {
                        return h - yScale(d.valueElementAverage);
                    }
                    // Total
                    else {
                        return h - yScale(d.valueElementTotal);
                    }
                })
                //10 Implement xScale
                .attr('width', xScale.bandwidth())
                .style('fill', 'transparent')
                //.transition().duration((d, e) => e * 500) // perform transition over 1 second
                //.delay((d, e) => e + 200)


                .style("fill", (d, e) => { return `rgb(20, 20, ${e * 15 + 80})` })
                // Add data information on tooltip when hover on each bar
                .on("mouseover", function (d, e) {
                    // Average
                    if (chartAggregation == "Average") {
                        tooltip
                            .html(`Element: ${e.element} <br>Value: ${e.valueElementAverage}`)
                            .style("visibility", "visible");
                    }
                    // Total
                    else {
                        tooltip
                            .html(`Element: ${e.element} <br>Value: ${e.valueElementTotal}`)
                            .style("visibility", "visible");
                    }

                    d3.select(this)
                        .attr("fill", "#000000");
                })
                .on("mousemove", function () {
                    tooltip
                        .style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function (d, e) {
                    tooltip.html(``).style("visibility", "hidden");
                    d3.select(this).attr("fill", `rgb(20, 20, ${e * 15 + 80})`);
                })
                .transition()
                .duration((d, e) => e * 500) // perform transition over 1 second
                .delay((d, e) => e + 200)
                .attr('height', (d, e) => {
                    // Average
                    if (chartAggregation == "Average") {
                        return h - yScale(d.valueElementAverage);
                    }
                    // Total
                    else {
                        return h - yScale(d.valueElementTotal);
                    }
                })
                // Place 'y' after height to get the bar graph built upward, not downward
                .attr('y', 0);

            // 14 Create Bar text
            newBarGroups
                .append('text')
                .attr("text-anchor", "middle")
                .attr('x', (d, e) => { return xScale.bandwidth() / 2; })
                .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
                .attr('fill', 'black')
                .style('font-size', '1em')
                .text((d, e) => {
                    // Average
                    if (chartAggregation == "Average") {
                        return Math.round(d.valueElementAverage).toLocaleString();
                    }
                    // Total
                    else {
                        return Math.round(d.valueElementTotal).toLocaleString();
                    }
                });

            // 11 Create the axis and add it to the svg

            //let yAxis = d3.axisLeft(yScale); // declare the axis generator
            //svg.append('g')
            //    .classed('axis y', true)
            //    .call(yAxis);
            // 12.5 Append the y-Axis to the chartGroup
            let yAxis = d3.axisLeft(yScale); // declare the axis generator
            chartGroup.append('g')
                .classed('axis y', true)
                .call(yAxis);

            // 13 Append the x-Axis to the chartGroup
            let xAxis = d3.axisBottom(xScale); // declare the axis generator
            chartGroup.append('g')
            .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
                .classed('axis x', true)
                .call(xAxis);

            // Style and Rotate the labels
            chartGroup.selectAll('.axis.x text')
                .attr("transform", "rotate(-70)")
                .attr("dx", "-0.8em")
                .attr("dy", "0.25em")
                .style("text-anchor", "end") // pull labels to bottom
                .style("font-size", "0.9em"); // set font size
        }

        // Graph for item total
        function buildGraphItem(dataSet) {
            console.log(dataSet)

            // Clear graph
            d3.selectAll('svg > g > *').remove();

            let valueItemsRangeAverage = "";
            let maxValueItemsAverage = "";

            let valueItemsRangeTotal = "";
            let maxValueItemsTotal = "";
            // 4 Calculate the maximum value to be displayed
            // Average
            if (chartAggregation == "Average") {
                valueItemsRangeAverage = d3.extent(dataSet, (d, i) => d.valueItemAverage);
                maxValueItemsAverage = valueItemsRangeAverage[1];

                console.log("Max totalItems average in build graph item: " + maxValueItemsAverage);
            }
            // Total
            else {
                valueItemsRangeTotal = d3.extent(dataSet, (d, i) => d.valueItemTotal);
                maxValueItemsTotal = valueItemsRangeTotal[1];

                console.log("Max totalItems total in build graph item: " + maxValueItemsTotal);
            }

            // 4 Calculate the bar dimensions
            const barMargin = 10;
            const barWidth = w / dataSet.length;

            console.log("Bar margin: " + barMargin);
            console.log("Bar width: " + barWidth);

            // 8 Create a YScale
            // Average
            let yScale = "";
            if (chartAggregation == "Average") {
                yScale = d3.scaleLinear()
                    .domain([0, maxValueItemsAverage])
                    .range([h, 0]);
            }
            // Total
            else {
                yScale = d3.scaleLinear()
                    .domain([0, maxValueItemsTotal])
                    .range([h, 0]);
            }

            // 10 Create XScale
            //let itemParentArray = Array.from(dataSet, (d, i) => `${d.item} - ${d.parentItem}`);
            let itemArray = Array.from(dataSet, (d, i) => d.item);
            console.log("array: " + itemArray)

            let xScale = d3.scaleBand()
                .domain(itemArray)
                .range([0, w])
                .paddingInner(0.1)

            // example of xScale test:
            console.log("xscale: " + xScale(1))

            // 12.4 Create chartGroup element
            const chartGroup = svg.append('g')
                .classed('chartGroup', true)
                .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

            //5 Select all 'g' elements and bind the dataSet
            //let barGroups = svg
            //    .selectAll('g')
            //    .data(dataSet);
            //12.4 Append the barGroups to the chartGroup
            let barGroups = chartGroup
                .selectAll('g')
                .data(dataSet);

            // 6 Add new bar groups
            let newBarGroups = barGroups.enter()
                .append('g')
                .attr('transform', (d, i) => {
                    // 9 Implement yScale

                    // 10 Implement xScale

                    let y = "";
                    // Average
                    if (chartAggregation == "Average") {
                        y = d.valueItemAverage >= 0 ? h - (d.valueItemAverage / maxValueItemsAverage) * h : h // if value is negative, set y coordinate to h, placing the bar below the chart
                    }
                    // Total
                    else {
                        y = d.valueItemTotal >= 0 ? h - (d.valueItemTotal / maxValueItemsTotal) * h : h
                    }
                    return `translate(${xScale(d.item)}, ${y})`;

                }); // end transform

            // Add tooltip to show data when hover on bar
            // Reference link: https://perials.github.io/responsive-bar-chart-with-d3/
            const tooltip = d3.select("body")
                .append("div")
                .attr("class", "d3-tooltip")
                .style("position", "absolute")
                .style("z-index", "10")
                .style("visibility", "hidden")
                .style("padding", "15px")
                .style("background", "rgba(0,0,0,0.6)")
                .style("border-radius", "5px")
                .style("color", "#fff")
                .text("a simple tooltip");
            // 7 Append new rectangles
            // 11 animate
            newBarGroups
                .append('rect')
                .attr('x', 0) // optional line that can be left out since 0 is the default
                .attr('height', (d, i) => {

                    // Average
                    if (chartAggregation == "Average") {
                        return Math.abs((d.valueItemAverage / maxValueItemsAverage) * h); // ensure that height is always positive
                    }
                    // Total
                    else {
                        return Math.abs((d.valueItemTotal / maxValueItemsTotal) * h);
                    }

                })

                // 9 Implement yScale
                //10 Implement xScale
                .attr('width', xScale.bandwidth())
                .style('fill', 'transparent')
                // Add data information on tooltip when hover on each bar
                .on("mouseover", function (d, i) {
                    // Average
                    if (chartAggregation == "Average") {
                        tooltip
                            .html(`Item: ${i.item} <br>Value: ${i.valueItemAverage}`)
                            .style("visibility", "visible");
                    }
                    // Total
                    else {
                        tooltip
                            .html(`Item: ${i.item} <br>Value: ${i.valueItemTotal}`)
                            .style("visibility", "visible");
                    }

                    d3.select(this)
                        .attr("fill", "#000000");
                })
                .on("mousemove", function () {
                    tooltip
                        .style("top", (event.pageY - 10) + "px")
                        .style("left", (event.pageX + 10) + "px");
                })
                .on("mouseout", function (d, i) {
                    tooltip.html(``).style("visibility", "hidden");
                    d3.select(this).attr("fill", `rgb(20, 20, ${i * 15 + 80})`);
                })
                .transition()
                .duration((d, i) => i * 200) // perform transition over 0.4 second
                .delay((d, i) => i + 200)
                .attr('y', 0)
                .style("fill", (d, i) => { return `rgb(20, 20, ${i * 15 + 80})` });

            // 14 Create Bar text
            //newBarGroups
            //    .append('text')
            //    .attr("text-anchor", "middle")
            //    .attr('x', (d, i) => { return xScale.bandwidth() / 2; })
            //    .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
            //    .attr('fill', 'black')
            //    .style('font-size', '0.45em')
            //    .text((d, i) => {
            //        // Average
            //        if (chartAggregation == "Average") {
            //            return d.valueItemAverage.toLocaleString();
            //        }
            //        // Total
            //        else {
            //            return d.valueItemTotal.toLocaleString();
            //        }
            //    })

            // 11 Create the axis and add it to the svg
            // 12.5 Append the y-Axis to the chartGroup
            let yAxis = d3.axisLeft(yScale); // declare the axis generator
            chartGroup.append('g')
                .classed('axis y', true)
                .call(yAxis);

            // 13 Append the x-Axis to the chartGroup
            let xAxis = d3.axisBottom(xScale); // declare the axis generator
            chartGroup.append('g')
                .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
                .classed('axis x', true)
                .call(xAxis);

            // Style and Rotate the labels
            chartGroup.selectAll('.axis.x text')
                .attr("transform", "rotate(-50)")
                .attr("dx", "-12em") // add margin left and right -> go negative to align left
                .attr("dy", "10em") // add margin top and bottom -> increase to go far more bottom
                .style("text-anchor", "end") // pull labels to bottom
                .style("font-size", "0.45em"); // set font size
        }

        // Get the idea of making a line chart from these links, then fix based on bar chart learned in class
        //https://www.educative.io/answers/how-to-create-a-line-chart-using-d3
        //https://itecnote.com/tecnote/javascript-d3-js-how-to-add-labels-to-scatter-points-on-graph/
        //https://chrissardegna.com/blog/lessons-in-d3-labeling/
        function buildGraphTemperature(dataSet) {

            //console.log("Data set: " + dataSet);// only console log dataSet, don't add any other string since it will change the type and result in [object, Object]
            console.log(dataSet)
            // Clear graph
            d3.selectAll('svg > g > *').remove();

            // Calculate the maximum value to be displayed
            let valueTemperatureRange = d3.extent(dataSet, (d, t) => d.value);
            let maxValueTemperature = valueTemperatureRange[1];

            console.log("Max totalItems in build graph item: " + maxValueTemperature);

            // Create array of data based on year
            let temperatureArray = Array.from(dataSet, (d, t) => d.year);
            console.log("array: " + temperatureArray);

            // Create XScale
            let xScale = d3.scaleBand()
                .domain(temperatureArray)
                .range([0, w])
                .paddingInner(0.1);

            //Create a YScale
            let yScale = d3.scaleLinear()
                .domain([0, maxValueTemperature])
                .range([h, 0]);

            // example of xScale test:
            console.log("xscale: " + xScale(1));

            // Create chartGroup element
            let chartGroup = svg.append('g')
                .classed('chartGroup', true)
                .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

            // Create line and generate path data for drawing lines on chart using d3.line()
            let lineGenerator = d3.line()
                .x(d => xScale(d.year)) // x coordinate of line
                .y(d => yScale(d.value)); // y coordinate of line

            // Append a path element to draw the line
            chartGroup.append('path')
                .datum(dataSet)
                .attr("class", "line")
                .attr('fill', 'none')
                .attr('stroke', 'red')
                .attr('stroke-width', 2)
                .attr('d', lineGenerator);

            // 11 Create the y-axis and add it to the svg
            let yAxis = d3.axisLeft(yScale); // declare the axis generator
            chartGroup.append('g')
                .classed('axis y', true)
                .call(yAxis);

            // 13 Append the x-axis to the chartGroup
            let xAxis = d3.axisBottom(xScale); // declare the axis generator
            chartGroup.append('g')
                .attr('transform', `translate(0,${h})`) // pull the x-axis to the bottom
                .classed('axis x', true)
                .call(xAxis);

            // Style x-axis labels
            chartGroup.selectAll('.axis.x text')
                .attr("transform", "rotate(-50)")
                .attr("dx", "-12em")
                .attr("dy", "5em")
                .style("text-anchor", "end")
                .style("font-size", "1em");

            // Add dots at data points
            chartGroup.selectAll(".dot")
                .data(dataSet)
                .enter()
                .append("circle")
                .attr("class", "dot")
                .attr("cx", d => xScale(d.year))
                .attr("cy", d => yScale(d.value))
                .attr("r", 3) // Add radius of dot
                .style("fill", "red"); // Set color of dot

            // Instead of scatter-label, tried dot-label because was using .dot above and it worked
            chartGroup.selectAll(".dot-label")
                .data(dataSet)
                .enter()
                .append('text')
                .attr("class", "dot-label")
                .attr("x", d => xScale(d.year))
                .attr("y", d => yScale(d.value) - 10) // Adjust the y position to place text above the dot
                .attr("text-anchor", "middle")
                .attr('fill', 'black')
                .style('font-size', '0.45em')
                .text(d => d.value.toLocaleString()); // Display the value as text
        }
    </script>
}
