@*@model Assig1.Models.Country*@
@*@model Assig1.ViewModels.Country_CountryDetail*@
@model Assig1.ViewModels.CountriesViewModel

@{
    ViewData["Title"] = "Details";
}

<h1>Details</h1>

<div class="row mb-3" id="dataDisplay">
    <div class="col-2">
        <select asp-for="@Model.Year" asp-items="@Model.YearList" class="form-control" id="year">
            <option value="">Select year</option>
        </select>
    </div>

    <div class="col-2">
        <select asp-for="@Model.ChartLegend" class="form-control" id="chartLegend">
            @*<option value="">Select Data</option>*@

            <option value="Elements">Elements</option>
            <option value="Items">Items</option>
        </select>
    </div>

    <div class="col-2">
        <select asp-for="@Model.ChartAggregation" class="form-control" id="chartAggregation">
            @*<option value="">Select Aggregation</option>*@
            <option value="Total">Total</option>
            <option value="Average">Average</option>
        </select>
    </div>

</div>

<div>
    <svg width="100%" height="600px" class="border border-primary rounded p-2"></svg>
</div>

<div class="row justify-content-end">
    <div class="col-4">
        <img src="@Model.TheCountryDetail.TheCountry.ImageUrl" class="card-img-top" alt="...">
        <p>Country: @Model.TheCountryDetail.TheCountry.CountryName</p>
        @if (Model.TheCountryDetail.TheRegion != null)
        {
            <p>Region: @Model.TheCountryDetail.TheRegion.RegionName</p>
            <a asp-action="Index" asp-route-countryId="@Model.TheCountryDetail.TheCountry.CountryId" asp-route-regionId="@Model.TheCountryDetail.TheRegion.RegionId" class="btn btn-outline-info">Countries List in same region</a>
        }
        else
        {
            <p>Region: no regions</p>
            <a asp-action="Index" asp-route-countryId="" class="btn btn-outline-info">All Countries List</a>
        }
        <a asp-controller="Cities" asp-action="Index" asp-route-countryId="@Model.TheCountryDetail.TheCountry.CountryId" class="btn btn-outline-success">Visit cities</a>

        @*<img src="@Model.TheCountryDetail.TheCountry.ImageUrl" class="card-img-top" alt="...">*@
        @*<img src="@Model.ImageUrl" class="card-img-top" alt="...">*@
    </div>
    <div class="col-1">

    </div>
    <div class="col-7">
        <div class="row justify-content-end">
            <div class="col-4">
                @*<img src="@Model.TheCountry.ImageUrl" class="card-img-top" alt="...">*@
                @*<img src="@Model.ImageUrl" class="card-img-top" alt="...">*@
            </div>
            <div class="col-1">

            </div>
            <div class="col-7">
            </div>
        </div>
    </div>
</div>

@section scripts{
    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        // 1 Select SVG element
        const svg = d3.select('svg');

        // 2 Determine the size of the SVG element
        let w = svg.node().getBoundingClientRect().width;
        let h = svg.node().getBoundingClientRect().height;

        console.log("Width: " + w);
        console.log("Height: " + h);

        // 12 Chart margins
        const chartMargins = {
            left: 40,
            right: 25,
            top: 25,
            bottom: 80
        };

        // 12 Update width and height variable to account for the reduction in size caused by margins
        w = w - (chartMargins.left + chartMargins.right);
        h = h - (chartMargins.top + chartMargins.bottom);

        // DDL year event listener
        // Fetch data every time an option is chosen
        document.querySelector('.row .col-2 #year').addEventListener('change', (yearEvent) => {
            let year = yearEvent.target.value;
            let chartLegend = "";
            let chartAggregation = "";
            console.log("Year: " + year);

            let url = `/Countries/CountryEmissionsReportData?countryId=${@Model.CountryId}&year=${year}&chartLegend=${chartLegend}&chartAggregation=${chartAggregation}`;

            if (year.length > 0) {

                if (chartLegend == "Items") {
                    fetch(url)
                        .then(response => {
                            console.log("response status: " + response.status);
                            console.log("response text: " + response.statusText);
                            return response.json();
                        })
                        .then(data => buildGraphItem(data))
                        .catch(err => console.log(err.message));
                }
                else {
                    fetch(url)
                        .then(response => {
                            console.log("response status: " + response.status);
                            console.log("response text: " + response.statusText);
                            return response.json();
                        })
                        .then(data => buildGraphElement(data))
                        .catch(err => console.log(err.message));
                    //}

                }

                document.querySelector('.row .col-2 #chartLegend').addEventListener('change', legendEvent => {
                    chartLegend = legendEvent.target.value;
                    console.log("Chart Legend: " + chartLegend);

                    let url = `/Countries/CountryEmissionsReportData?countryId=${@Model.CountryId}&year=${year}&chartLegend=${chartLegend}&chartAggregation=${chartAggregation}`;

                    if (year.length > 0) {

                        if (chartLegend == "Items") {
                            fetch(url)
                                .then(response => {
                                    console.log("response status: " + response.status);
                                    console.log("response text: " + response.statusText);
                                    return response.json();
                                })
                                .then(data => buildGraphItem(data))
                                .catch(err => console.log(err.message));
                        }
                        else {
                            fetch(url)
                                .then(response => {
                                    console.log("response status: " + response.status);
                                    console.log("response text: " + response.statusText);
                                    return response.json();
                                })
                                .then(data => buildGraphElement(data))
                                .catch(err => console.log(err.message));
                        }

                    }
                })
                document.querySelector('.row .col-2 #chartAggregation').addEventListener('change', aggregationEvent => {
                    chartAggregation = aggregationEvent.target.value;
                    console.log("Chart Aggregation: " + chartAggregation);

                    let url = `/Countries/CountryEmissionsReportData?countryId=${@Model.CountryId}&year=${year}&chartLegend=${chartLegend}&chartAggregation=${chartAggregation}`;

                    if (year.length > 0) {

                        if (chartLegend == "Items") {
                            fetch(url)
                                .then(response => {
                                    console.log("response status: " + response.status);
                                    console.log("response text: " + response.statusText);
                                    return response.json();
                                })
                                .then(data => buildGraphItem(data))
                                .catch(err => console.log(err.message));
                        }
                        else {
                            fetch(url)
                                .then(response => {
                                    console.log("response status: " + response.status);
                                    console.log("response text: " + response.statusText);
                                    return response.json();
                                })
                                .then(data => buildGraphElement(data))
                                .catch(err => console.log(err.message));
                        }

                    }
                })
            }
        })

        // Alternate using D3
        //d3.select('.row .col-2 [name="year"]').on('change', (event) => {
        // fetch using event.target.value
        //})

        // TESTING FOR ELEMENTS TOTAL
        // maybe only need buildgraph element and item, don't need to differentiate element and item because it just builds graph upon data
        // dataSet.length is number of items in the dataSet => elements: 8 for countryid=1
        function buildGraphElement(dataSet) {
            console.log(dataSet)

            // Clear graph
            d3.selectAll('svg > g > *').remove();

            // 4 Calculate the maximum value to be displayed
            let totalElementsRange = d3.extent(dataSet, (d, e) => d.totalValueElement);
            let maxTotalElements = totalElementsRange[1];

            console.log("Max totalElements: " + maxTotalElements);

            // 4 Calculate the bar dimensions
            const barMargin = 10;
            const barWidth = w / dataSet.length;

            // 8 Create a YScale
            let yScale = d3.scaleLinear()
                .domain([0, maxTotalElements])
                .range([h, 0]);

            // 10 Create XScale
            let elementArray = Array.from(dataSet, (d, e) => d.element);
            console.log("array: " + elementArray)

            let xScale = d3.scaleBand()
                .domain(elementArray)
                .range([0, w])
                .paddingInner(0.1)

            // example of xScale test:
            console.log("xscale: " + xScale(1))

            // 12.4 Create chartGroup element
            const chartGroup = svg.append('g')
                .classed('chartGroup', true)
                .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

            // 5 Select all 'g' elements and bind the dataSet
            //let barGroups = svg
            //    .selectAll('g')
            //    .data(dataSet);
            // 12.4 Append the barGroups to the chartGroup
            let barGroups = chartGroup
                .selectAll('g')
                .data(dataSet);

            // 6 Add new bar groups
            let newBarGroups = barGroups.enter()
                .append('g')
                .attr('transform', (d, e) => {
                    // 9 Implement yScale
                    //return `translate(${e * barWidth}, ${yScale(d.totalValue)})`;

                    // 10 Implement xScale
                    return `translate(${xScale(d.element)}, ${yScale(d.totalValueElement)})`;
                    //return `translate(${e * barWidth}, ${h - (d.totalValue / maxTotalElements) * h})`;
                    // returns transform="translate(x,y)"
                }); // end transform

            // 7 Append new rectangles
            // 11 animate
            newBarGroups
                .append('rect')
                .attr('x', 0) // optional line that can be left out since 0 is the default
                //.attr('height', (d, e) => { return d.totalValue / maxTotalElements * h; })
                // 9 Implement yScale
                .attr('height', 0)
                .attr('y', (d, e) => { return h - yScale(d.totalValueElement); })
                //.attr('width', barWidth - barMargin)
                //10 Implement xScale
                .attr('width', xScale.bandwidth())
                .style('fill', 'transparent')
                .transition().duration((d, e) => e * 500) // perform transition over 1 second
                .delay((d, e) => e + 200)
                .attr('y', 0)
                .attr('height', (d, e) => { return h - yScale(d.totalValueElement); })
                .style("fill", (d, e) => { return `rgb(20, 20, ${e * 15 + 80})` });
                //.attr('fill', 'blue')

            // 14 Create Bar text
            newBarGroups
                .append('text')
                .attr("text-anchor", "middle")
                .attr('x', (d, e) => { return xScale.bandwidth() / 2; })
                .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
                .attr('fill', 'black')
                .style('font-size', '1em')
                .text((d, e) => d.totalValueElement.toLocaleString());

            // 11 Create the axis and add it to the svg

            //let yAxis = d3.axisLeft(yScale); // declare the axis generator
            //svg.append('g')
            //    .classed('axis y', true)
            //    .call(yAxis);
            // 12.5 Append the y-Axis to the chartGroup
            let yAxis = d3.axisLeft(yScale); // declare the axis generator
            chartGroup.append('g')
                .classed('axis y', true)
                .call(yAxis);

            // 13 Append the x-Axis to the chartGroup
            let xAxis = d3.axisBottom(xScale); // declare the axis generator
            chartGroup.append('g')
            .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
                .classed('axis x', true)
                .call(xAxis);

            // Style and Rotate the labels
            chartGroup.selectAll('.axis.x text')
                .attr("transform", "rotate(-70)")
                .attr("dx", "-0.8em")
                .attr("dy", "0.25em")
                .style("text-anchor", "end") // pull labels to bottom
                .style("font-size", "0.9em"); // set font size
        }

        // Graph for element average
        //function buildGraphElementAverage(dataSet) {
        //    console.log(dataSet)

        //    // Clear graph
        //    d3.selectAll('svg > g > *').remove();

        //    // 4 Calculate the maximum value to be displayed
        //    let averageElementsRange = d3.extent(dataSet, (d, e) => d.averageValueElement);
        //    let maxAverageElements = averageElementsRange[1];

        //    console.log("Max averageElements: " + maxAverageElements);

        //    // 4 Calculate the bar dimensions
        //    const barMargin = 10;
        //    const barWidth = w / dataSet.length;

        //    // 8 Create a YScale
        //    let yScale = d3.scaleLinear()
        //        .domain([0, maxAverageElements])
        //        .range([h, 0]);

        //    // 10 Create XScale
        //    let elementArray = Array.from(dataSet, (d, e) => d.element);
        //    console.log("array: " + elementArray)

        //    let xScale = d3.scaleBand()
        //        .domain(elementArray)
        //        .range([0, w])
        //        .paddingInner(0.1)

        //    // example of xScale test:
        //    console.log("xscale: " + xScale(1))

        //    // 12.4 Create chartGroup element
        //    const chartGroup = svg.append('g')
        //        .classed('chartGroup', true)
        //        .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

        //    // 5 Select all 'g' elements and bind the dataSet
        //    //let barGroups = svg
        //    //    .selectAll('g')
        //    //    .data(dataSet);
        //    // 12.4 Append the barGroups to the chartGroup
        //    let barGroups = chartGroup
        //        .selectAll('g')
        //        .data(dataSet);

        //    // 6 Add new bar groups
        //    let newBarGroups = barGroups.enter()
        //        .append('g')
        //        .attr('transform', (d, e) => {
        //            // 9 Implement yScale
        //            //return `translate(${e * barWidth}, ${yScale(d.totalValue)})`;

        //            // 10 Implement xScale
        //            return `translate(${xScale(d.element)}, ${yScale(d.averageValueElement)})`;
        //            //return `translate(${e * barWidth}, ${h - (d.totalValue / maxTotalElements) * h})`;
        //            // returns transform="translate(x,y)"
        //        }); // end transform

        //    // 7 Append new rectangles
        //    // 11 animate
        //    newBarGroups
        //        .append('rect')
        //        .attr('x', 0) // optional line that can be left out since 0 is the default
        //        //.attr('height', (d, e) => { return d.totalValue / maxTotalElements * h; })
        //        // 9 Implement yScale
        //        .attr('height', 0)
        //        .attr('y', (d, e) => { return h - yScale(d.averageValueElement); })
        //        //.attr('width', barWidth - barMargin)
        //        //10 Implement xScale
        //        .attr('width', xScale.bandwidth())
        //        .style('fill', 'transparent')
        //        .transition().duration((d, e) => e * 500) // perform transition over 1 second
        //        .delay((d, e) => e + 200)
        //        .attr('y', 0)
        //        .attr('height', (d, e) => { return h - yScale(d.averageValueElement); })
        //        .style("fill", (d, e) => { return `rgb(20, 20, ${e * 15 + 80})` });
        //    //.attr('fill', 'blue')

        //    // 14 Create Bar text
        //    newBarGroups
        //        .append('text')
        //        .attr("text-anchor", "middle")
        //        .attr('x', (d, e) => { return xScale.bandwidth() / 2; })
        //        .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
        //        .attr('fill', 'black')
        //        .style('font-size', '1em')
        //        .text((d, e) => d.averageValueElement.toLocaleString());

        //    // 11 Create the axis and add it to the svg

        //    //let yAxis = d3.axisLeft(yScale); // declare the axis generator
        //    //svg.append('g')
        //    //    .classed('axis y', true)
        //    //    .call(yAxis);
        //    // 12.5 Append the y-Axis to the chartGroup
        //    let yAxis = d3.axisLeft(yScale); // declare the axis generator
        //    chartGroup.append('g')
        //        .classed('axis y', true)
        //        .call(yAxis);

        //    // 13 Append the x-Axis to the chartGroup
        //    let xAxis = d3.axisBottom(xScale); // declare the axis generator
        //    chartGroup.append('g')
        //        .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
        //        .classed('axis x', true)
        //        .call(xAxis);

        //    // Style and Rotate the labels
        //    chartGroup.selectAll('.axis.x text')
        //        .attr("transform", "rotate(-70)")
        //        .attr("dx", "-0.8em")
        //        .attr("dy", "0.25em")
        //        .style("text-anchor", "end") // pull labels to bottom
        //        .style("font-size", "0.9em"); // set font size
        //}

        // Graph for item total
        function buildGraphItem(dataSet) {
            console.log(dataSet)

            // Clear graph
            d3.selectAll('svg > g > *').remove();

            // 4 Calculate the maximum value to be displayed
            let totalItemsRange = d3.extent(dataSet, (d, i) => d.totalValueItem);
            let maxTotalItems = totalItemsRange[1];

            console.log("Max totalItems: " + maxTotalItems);

            // 4 Calculate the bar dimensions
            const barMargin = 10;
            const barWidth = w / dataSet.length;

            // 8 Create a YScale
            let yScale = d3.scaleLinear()
                .domain([0, maxTotalItems])
                .range([h, 0]);

            // 10 Create XScale
            let itemArray = Array.from(dataSet, (d, i) => d.item);
            console.log("array: " + itemArray)

            let xScale = d3.scaleBand()
                .domain(itemArray)
                .range([0, w])
                .paddingInner(0.1)

            // example of xScale test:
            console.log("xscale: " + xScale(1))

            // 12.4 Create chartGroup element
            const chartGroup = svg.append('g')
                .classed('chartGroup', true)
                .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

            // 5 Select all 'g' elements and bind the dataSet
            //let barGroups = svg
            //    .selectAll('g')
            //    .data(dataSet);
            // 12.4 Append the barGroups to the chartGroup
            let barGroups = chartGroup
                .selectAll('g')
                .data(dataSet);

            // 6 Add new bar groups
            let newBarGroups = barGroups.enter()
                .append('g')
                .attr('transform', (d, i) => {
                    // 9 Implement yScale
                    //return `translate(${e * barWidth}, ${yScale(d.totalValue)})`;

                    // 10 Implement xScale
                    return `translate(${xScale(d.item)}, ${yScale(d.totalValueItem)})`;
                    //return `translate(${e * barWidth}, ${h - (d.totalValue / maxTotalElements) * h})`;
                    // returns transform="translate(x,y)"
                }); // end transform

            // 7 Append new rectangles
            // 11 animate
            newBarGroups
                .append('rect')
                .attr('x', 0) // optional line that can be left out since 0 is the default
                //.attr('height', (d, e) => { return d.totalValue / maxTotalElements * h; })
                // 9 Implement yScale
                .attr('height', 0)
                .attr('y', (d, i) => { return h - yScale(d.totalValueItem); })
                //.attr('width', barWidth - barMargin)
                //10 Implement xScale
                .attr('width', xScale.bandwidth())
                .style('fill', 'transparent')
                .transition().duration((d, i) => i * 500) // perform transition over 1 second
                .delay((d, i) => i + 200)
                .attr('y', 0)
                .attr('height', (d, i) => { return h - yScale(d.totalValueItem); })
                .style("fill", (d, i) => { return `rgb(20, 20, ${i * 15 + 80})` });
            //.attr('fill', 'blue')

            // 14 Create Bar text
            newBarGroups
                .append('text')
                .attr("text-anchor", "middle")
                .attr('x', (d, i) => { return xScale.bandwidth() / 2; })
                .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
                .attr('fill', 'black')
                .style('font-size', '1em')
                .text((d, i) => d.totalValueItem.toLocaleString());

            // 11 Create the axis and add it to the svg

            //let yAxis = d3.axisLeft(yScale); // declare the axis generator
            //svg.append('g')
            //    .classed('axis y', true)
            //    .call(yAxis);
            // 12.5 Append the y-Axis to the chartGroup
            let yAxis = d3.axisLeft(yScale); // declare the axis generator
            chartGroup.append('g')
                .classed('axis y', true)
                .call(yAxis);

            // 13 Append the x-Axis to the chartGroup
            let xAxis = d3.axisBottom(xScale); // declare the axis generator
            chartGroup.append('g')
                .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
                .classed('axis x', true)
                .call(xAxis);

            // Style and Rotate the labels
            chartGroup.selectAll('.axis.x text')
                .attr("transform", "rotate(-70)")
                .attr("dx", "-0.8em")
                .attr("dy", "0.25em")
                .style("text-anchor", "end") // pull labels to bottom
                .style("font-size", "0.9em"); // set font size
        }

        // Graph for item average
        //function buildGraphItemAverage(dataSet) {
        //    console.log(dataSet)

        //    // Clear graph
        //    d3.selectAll('svg > g > *').remove();

        //    // 4 Calculate the maximum value to be displayed
        //    let averageItemsRange = d3.extent(dataSet, (d, i) => d.averageValueItem);
        //    let maxAverageItems = averageElementsRange[1];

        //    console.log("Max averageElements: " + maxAverageItems);

        //    // 4 Calculate the bar dimensions
        //    const barMargin = 10;
        //    const barWidth = w / dataSet.length;

        //    // 8 Create a YScale
        //    let yScale = d3.scaleLinear()
        //        .domain([0, maxAverageItems])
        //        .range([h, 0]);

        //    // 10 Create XScale
        //    let itemArray = Array.from(dataSet, (d, i) => d.item);
        //    console.log("array: " + itemArray)

        //    let xScale = d3.scaleBand()
        //        .domain(itemArray)
        //        .range([0, w])
        //        .paddingInner(0.1)

        //    // example of xScale test:
        //    console.log("xscale: " + xScale(1))

        //    // 12.4 Create chartGroup element
        //    const chartGroup = svg.append('g')
        //        .classed('chartGroup', true)
        //        .attr('transform', `translate(${chartMargins.left},${chartMargins.top})`);

        //    // 5 Select all 'g' elements and bind the dataSet
        //    //let barGroups = svg
        //    //    .selectAll('g')
        //    //    .data(dataSet);
        //    // 12.4 Append the barGroups to the chartGroup
        //    let barGroups = chartGroup
        //        .selectAll('g')
        //        .data(dataSet);

        //    // 6 Add new bar groups
        //    let newBarGroups = barGroups.enter()
        //        .append('g')
        //        .attr('transform', (d, i) => {
        //            // 9 Implement yScale
        //            //return `translate(${e * barWidth}, ${yScale(d.totalValue)})`;

        //            // 10 Implement xScale
        //            return `translate(${xScale(d.item)}, ${yScale(d.averageValueItem)})`;
        //            //return `translate(${e * barWidth}, ${h - (d.totalValue / maxTotalElements) * h})`;
        //            // returns transform="translate(x,y)"
        //        }); // end transform

        //    // 7 Append new rectangles
        //    // 11 animate
        //    newBarGroups
        //        .append('rect')
        //        .attr('x', 0) // optional line that can be left out since 0 is the default
        //        //.attr('height', (d, e) => { return d.totalValue / maxTotalElements * h; })
        //        // 9 Implement yScale
        //        .attr('height', 0)
        //        .attr('y', (d, i) => { return h - yScale(d.averageValueItem); })
        //        //.attr('width', barWidth - barMargin)
        //        //10 Implement xScale
        //        .attr('width', xScale.bandwidth())
        //        .style('fill', 'transparent')
        //        .transition().duration((d, e) => e * 500) // perform transition over 1 second
        //        .delay((d, i) => i + 200)
        //        .attr('y', 0)
        //        .attr('height', (d, i) => { return h - yScale(d.averageValueItem); })
        //        .style("fill", (d, i) => { return `rgb(20, 20, ${i * 15 + 80})` });
        //    //.attr('fill', 'blue')

        //    // 14 Create Bar text
        //    newBarGroups
        //        .append('text')
        //        .attr("text-anchor", "middle")
        //        .attr('x', (d, i) => { return xScale.bandwidth() / 2; })
        //        .attr('y', -10) // change whether bar text will appear inside or outside bar, 20 makes it stay inside bar
        //        .attr('fill', 'black')
        //        .style('font-size', '1em')
        //        .text((d, i) => d.averageValueItem.toLocaleString());

        //    // 11 Create the axis and add it to the svg

        //    //let yAxis = d3.axisLeft(yScale); // declare the axis generator
        //    //svg.append('g')
        //    //    .classed('axis y', true)
        //    //    .call(yAxis);
        //    // 12.5 Append the y-Axis to the chartGroup
        //    let yAxis = d3.axisLeft(yScale); // declare the axis generator
        //    chartGroup.append('g')
        //        .classed('axis y', true)
        //        .call(yAxis);

        //    // 13 Append the x-Axis to the chartGroup
        //    let xAxis = d3.axisBottom(xScale); // declare the axis generator
        //    chartGroup.append('g')
        //        .attr('transform', `translate(0,${h})`) // pull the xAxis to the bottm
        //        .classed('axis x', true)
        //        .call(xAxis);

        //    // Style and Rotate the labels
        //    chartGroup.selectAll('.axis.x text')
        //        .attr("transform", "rotate(-70)")
        //        .attr("dx", "-0.8em")
        //        .attr("dy", "0.25em")
        //        .style("text-anchor", "end") // pull labels to bottom
        //        .style("font-size", "0.9em"); // set font size
        //}
    </script>
}
<div>
    @*<h4>Country</h4>
        <hr />
        <dl class="row">
            <dt class = "col-sm-2">
                @Html.DisplayNameFor(model => model.Iso3)
            </dt>
            <dd class = "col-sm-10">
                @Html.DisplayFor(model => model.Iso3)
            </dd>
            <dt class = "col-sm-2">
                @Html.DisplayNameFor(model => model.CountryName)
            </dt>
            <dd class = "col-sm-10">
                @Html.DisplayFor(model => model.CountryName)
            </dd>
            <dt class = "col-sm-2">
                @Html.DisplayNameFor(model => model.ImageUrl)
            </dt>
            <dd class = "col-sm-10">
                @Html.DisplayFor(model => model.ImageUrl)
            </dd>
            <dt class = "col-sm-2">
                @Html.DisplayNameFor(model => model.Region)
            </dt>
            <dd class = "col-sm-10">
                @Html.DisplayFor(model => model.Region.RegionId)
            </dd>
        </dl>*@
</div>
<div>
    @*<a asp-action="Edit" asp-route-id="@Model?@Model.TheCountry.CountryId">Edit</a> |*@
    @*<a asp-action="Index">Back to List</a>*@
</div>
